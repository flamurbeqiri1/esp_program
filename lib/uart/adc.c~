// Copyright (C) 2003-2015 swengLab Technologies - All rights reserved
// Siebenb√ºrgerstrasse 16-26/26/17, A--1220 Vienna, Austria. 
// Author: Dr. SMAILI Idriz   smaili.idriz@gmail.com
//
//++
// Name
//    @file adc.c
//
// Purpose
//    @brief Implements the routine needed to handle the ADC  
//
// Author
//    @author: Dr. Dipl.-Ing. Idriz SMAILI, smaili.idriz@gmail.com
//    $Author: smaili $
//
// Revision Dates
//    2017-12-28 (smaili): Initial version
//    $Log: adc.c $
//--

#include "adc.h"

/***************************************************************************//** 
 * @brief Initialize the ADC 
 *
 * Initializes the ADC by providing the prescaler div factor. The Avcc is used.
 *
 * @param[in] uint8_t  specifies the prescaler div factor
 *
 * @retval void 
 ******************************************************************************/
void adc_init (uint8_t presc_fact)
{
  // specify the Aref=AVcc;
  ADMUX   = (1 << REFS0);

  // clear prescaler bits
  ADCSRA &= ~((1 << ADPS0) | (1 << ADPS1) | ( 1 << ADPS2)); 

  /* set the predefined prescaler */
  ADCSRA |= presc_fact;

  /* enables conversion */
  ADCSRA |= (1 << ADEN)
}

/***************************************************************************//** 
 * @brief Reads a raw value from the ADC 
 *
 * Reads the raw value from the specified ADC channel.
 *
 * @param[in] uint8_t  specifies the prescaler div factor
 *
 * @retval ADC_NO_ERROR         if the adc channel has been read successfully
 * @retval ADC_INVALID_CHANNEL  if a wrong adc channel was selected
 * @retval ADC_SHORT_2GND       if a short to ground has been detected
 * @retval ADC_SHORT_2BATTERY   if a short to batery has been detected
 ******************************************************************************/
char adc_get_raw (adc_t *const raw_value, uint8_t channel)
{
  if (channel > 7) 
    {
      return ADC_INVALID_CHANNEL;
    }
  
  /* select the ADC Channel ch must be 0-7 */
  ADMUX   |= channel;

  /* start single conversion */
  ADCSRA  |= (1 << ADSC);

  /* wait for conversion to complete */
  while (! (ADCSRA & (1 << ADIF)));

  raw_value->l_value = ADCL;
  raw_value->h_value = ADCH;

  /* clear ADIF by writing one to it -> make it ready for the next adc conversion */
  ADCSRA |= (1<<ADIF);

  if ((raw_value->l_value == 0) && (raw_value->h_value == 0))
    {
      return ADC_SHORT_2GND;
    }
  else if ((raw_value->l_value == 0xFF) && (raw_value->h_value == 0x03))
    {
      return ADC_INVALID_CHANNEL;
    }

  return ADC_NO_ERROR;
}

